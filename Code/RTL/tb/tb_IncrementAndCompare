`timescale 1 ns / 1 ps
module tb_IncrementAndCompare;
    
    parameter   STEP_SIZE = 1,
                INC_TERM_DW_INTEGER = 16,
                N_DW_INTEGER = 13,
                ERROR_DW_INTEGER = 14,
                A_DW_INTEGER = 4,
                DW_FRACTIONAL = 4;

    // input signals
    reg                                                 clk, rst, initiate, ack;
    reg [N_DW_INTEGER+DW_FRACTIONAL:0]                  n_prev;
    reg signed [A_DW_INTEGER+DW_FRACTIONAL:0]           a_prev;
    reg [2*A_DW_INTEGER+DW_FRACTIONAL:0]                a_prev_sq;
    reg signed [INC_TERM_DW_INTEGER+DW_FRACTIONAL:0]    comp_term;
    reg signed [INC_TERM_DW_INTEGER+DW_FRACTIONAL:0]    comp_term_prev;
    reg signed [ERROR_DW_INTEGER+DW_FRACTIONAL:0]       error_prev;

    reg signed [31:0][INC_TERM_DW_INTEGER+DW_FRACTIONAL:0] comp_term_array = {
        {21'b00000000001101101_1010},          // 109.625
        {21'b00000000010001110_1001},         // 142.5625
        {21'b00000000010101111_1000},         // 175.5
        {21'b00000000011010000_0111},         // 208.4375
        {21'b00000000011110001_0110},         // 241.375
        {21'b00000000100010010_0101},        // 274.3125
        {21'b00000000100110011_0101},        // 307.3125
        {21'b00000000101010100_0100},        // 340.25
        {21'b00000000101110101_0011},        // 373.1875
        {21'b00000000110010110_0010},        // 406.125
        {21'b00000000110110111_0001},        // 439.0625
        {21'b00000000111010111_1111},        // 471.9375
        {21'b00000000111111000_1111},        // 504.9375
        {21'b00000001000011001_1110},       // 537.875
        {21'b00000001000111010_1100},       // 570.75
        {21'b00000001001011011_1100},       // 603.75
        {21'b00000001001111100_1100},       // 636.75
        {21'b00000001010011101_1010},       // 669.625
        {21'b00000001010111110_1001},       // 702.5625
        {21'b00000001011011111_1000},       // 735.5
        {21'b00000001100000000_1000},       // 768.5
        {21'b00000001100100001_0110},       // 801.375
        {21'b00000001101000010_0110},       // 834.375
        {21'b00000001101100011_0101},       // 867.3125
        {21'b00000001110000100_0100},       // 900.25
        {21'b00000001110100101_0011},       // 933.1875
        {21'b00000001111000110_0010},       // 966.125
        {21'b00000001111100111_0001},       // 999.0625
        {21'b00000010000001000_0000},      // 1032.0
        {21'b00000010000101000_1111},      // 1064.9375
        {21'b00000010001001001_1110},      // 1097.875
        {21'b00000010001101010_1110}        // 1130.875
    };

    // output signals
    wire [N_DW_INTEGER+DW_FRACTIONAL:0]                 n_next;
    wire signed [ERROR_DW_INTEGER+DW_FRACTIONAL:0]      error_next;
    wire signed [A_DW_INTEGER+DW_FRACTIONAL:0]          a_next;
    wire [2*A_DW_INTEGER+DW_FRACTIONAL:0]               a_next_sq;
    wire signed [INC_TERM_DW_INTEGER+DW_FRACTIONAL:0]   comp_term_next;
    wire                                                ready;

    integer i;

    // generation of the clock signal
    always  #5 clk = ~clk;

    // Stimuli
    initial begin
        clk = 0; rst = 0; initiate = 0; ack = 0;

        // Initial input
        n_prev           = 17'b0000000010000_0100;  //  16.25
        a_prev           = 8'b0010_0000;            //  2
        a_prev_sq        = 10'b000100_0000;         //  4
        comp_term        = comp_term_array[31];
        comp_term_prev   = '0;                      //  0
        error_prev       = '0;                      //  0
        #5 rst           = 1;
        #40 rst          = 0;
        #70 initiate     = 1;
        #20  initiate    = 0;

        // Looping outputs to input of next calculation
        for (i = 31; i > 0; i = i - 1) begin
            wait(ready == 1'b1);
            n_prev          = n_next;
            a_prev          = a_next;
            a_prev_sq       = a_next_sq;
            comp_term_prev  = comp_term_next;
            error_prev      = error_next;

            ack             = 1;
            #20  ack        = 0;

            comp_term       = comp_term_array[i];

            #20 initiate    = 1;
            #20 initiate    = 0;
        end


        //n_prev           = 17'b0000000010011_0000;       // 19.2338
        //a_prev           = 8'b0011_0000;                 // 3
        //a_prev_sq        = 10'b001001_0000;              // 9
        //comp_term        = 20'b0000010001110_1000;       // 142.5
        //comp_term_prev   = 20'b0000001101010_0110;       // 106.4026
        //error_prev       = 18'b00000000000011_0100;      // 3.2264
//
//
        //#100 ack        = 1;
        //#20  ack        = 0;
        //#40 
        //n_prev           = 17'b0000010001001_1100;       // 137.75
        //a_prev           = 8'b0100_0100;                 // 4.25
        //a_prev_sq        = 10'b010010_0001;              // 18.0625
        //comp_term        = 20'b0010001101010_1101;       // 1130.8125
        //comp_term_prev   = 20'b0010010000000_1011;       // 1152.6875
        //error_prev       = 18'b00000000001001_0111;      // 9.4375
        //#40 initiate     = 1;
        //#20 initiate     = 0;
//
        //#100 ack        = 1;
        //#20  ack        = 0;
        //#40 
        //n_prev           = 17'b0000000010000_0100;  //16.25
        //a_prev           = 9'b11110_0000;             //-2;
        //a_prev_sq        = 10'b00000100_0000;       // 4
        //comp_term        = 21'b11111111110110100_0000;       // -76.6875
        //comp_term_prev   = 0;
        //error_prev       = 0;
        //#40 initiate     = 1;
    end

    // Input values

    // Instantiating the calculator module
    IncrementAndCompare #(
        .STEP_SIZE(STEP_SIZE),
        .INC_TERM_DW_INTEGER(INC_TERM_DW_INTEGER),
        .N_DW_INTEGER(N_DW_INTEGER),
        .ERROR_DW_INTEGER(ERROR_DW_INTEGER),
        .A_DW_INTEGER(A_DW_INTEGER),
        .DW_FRACTIONAL(DW_FRACTIONAL)
    ) inst1 (
        .clk(clk),
        .rst(rst),
        // Input
        .initiate(initiate),
        .ack(ack),
        .n_prev(n_prev),
        .a_prev(a_prev),
        .a_prev_sq(a_prev_sq),
        .comp_term(comp_term),
        .comp_term_prev(comp_term_prev),
        .error_prev(error_prev),
        // Output
        .n_next(n_next),
        .error_next(error_next),
        .a_next(a_next),
        .a_next_sq(a_next_sq),
        .comp_term_next(comp_term_next),
        .ready(ready)
    );


    real in_n_prev_fixed,in_a_prev_fixed,in_a_prev_sq_fixed,in_comp_term_fixed,in_comp_term_prev_fixed,in_error_prev_fixed;
    real out_n_next_fixed,out_error_next_fixed,out_a_next_fixed,out_a_next_sq_fixed,out_comp_term_next_fixed;
    always @* begin
        in_n_prev_fixed            = n_prev*(2.0**-4);
        in_a_prev_sq_fixed         = a_prev_sq*(2.0**-4);
        in_a_prev_fixed            = a_prev*(2.0**-4);          // SIGNED
        in_comp_term_fixed         = comp_term*(2.0**-4);       // SIGNED
        in_comp_term_prev_fixed    = comp_term_prev*(2.0**-4);  // SIGNED
        in_error_prev_fixed        = error_prev*(2.0**-4);      // SIGNED

        out_n_next_fixed            = n_next*(2.0**-4);
        out_error_next_fixed        = error_next*(2.0**-4);     // SIGNED
        out_a_next_fixed            = a_next*(2.0**-4);         // SIGNED
        out_a_next_sq_fixed         = a_next_sq*(2.0**-4);
        out_comp_term_next_fixed    = comp_term_next*(2.0**-4); // SIGNED
    end
endmodule
